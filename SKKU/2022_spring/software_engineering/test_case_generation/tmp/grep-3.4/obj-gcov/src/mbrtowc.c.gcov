        -:    0:Source:../../lib/mbrtowc.c
        -:    0:Programs:50
        -:    1:/* Convert multibyte character to wide character.
        -:    2:   Copyright (C) 1999-2002, 2005-2020 Free Software Foundation, Inc.
        -:    3:   Written by Bruno Haible <bruno@clisp.org>, 2008.
        -:    4:
        -:    5:   This program is free software: you can redistribute it and/or modify
        -:    6:   it under the terms of the GNU General Public License as published by
        -:    7:   the Free Software Foundation; either version 3 of the License, or
        -:    8:   (at your option) any later version.
        -:    9:
        -:   10:   This program is distributed in the hope that it will be useful,
        -:   11:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13:   GNU General Public License for more details.
        -:   14:
        -:   15:   You should have received a copy of the GNU General Public License
        -:   16:   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
        -:   17:
        -:   18:#include <config.h>
        -:   19:
        -:   20:/* Specification.  */
        -:   21:#include <wchar.h>
        -:   22:
        -:   23:#if MBRTOWC_IN_C_LOCALE_MAYBE_EILSEQ
        -:   24:# include "hard-locale.h"
        -:   25:# include <locale.h>
        -:   26:#endif
        -:   27:
        -:   28:#if GNULIB_defined_mbstate_t
        -:   29:/* Implement mbrtowc() on top of mbtowc().  */
        -:   30:
        -:   31:# include <errno.h>
        -:   32:# include <stdint.h>
        -:   33:# include <stdlib.h>
        -:   34:
        -:   35:# include "localcharset.h"
        -:   36:# include "streq.h"
        -:   37:# include "verify.h"
        -:   38:# include "glthread/lock.h"
        -:   39:
        -:   40:# ifndef FALLTHROUGH
        -:   41:#  if __GNUC__ < 7
        -:   42:#   define FALLTHROUGH ((void) 0)
        -:   43:#  else
        -:   44:#   define FALLTHROUGH __attribute__ ((__fallthrough__))
        -:   45:#  endif
        -:   46:# endif
        -:   47:
        -:   48:/* Returns a classification of special values of the encoding of the current
        -:   49:   locale.  */
        -:   50:typedef enum {
        -:   51:  enc_other,      /* other */
        -:   52:  enc_utf8,       /* UTF-8 */
        -:   53:  enc_eucjp,      /* EUC-JP */
        -:   54:  enc_94,         /* EUC-KR, GB2312, BIG5 */
        -:   55:  enc_euctw,      /* EUC-TW */
        -:   56:  enc_gb18030,    /* GB18030 */
        -:   57:  enc_sjis        /* SJIS */
        -:   58:} enc_t;
        -:   59:static inline enc_t
        -:   60:locale_enc (void)
        -:   61:{
        -:   62:  const char *encoding = locale_charset ();
        -:   63:  if (STREQ_OPT (encoding, "UTF-8", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))
        -:   64:    return enc_utf8;
        -:   65:  if (STREQ_OPT (encoding, "EUC-JP", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))
        -:   66:    return enc_eucjp;
        -:   67:  if (STREQ_OPT (encoding, "EUC-KR", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)
        -:   68:      || STREQ_OPT (encoding, "GB2312", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)
        -:   69:      || STREQ_OPT (encoding, "BIG5", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))
        -:   70:    return enc_94;
        -:   71:  if (STREQ_OPT (encoding, "EUC-TW", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))
        -:   72:    return enc_euctw;
        -:   73:  if (STREQ_OPT (encoding, "GB18030", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))
        -:   74:    return enc_gb18030;
        -:   75:  if (STREQ_OPT (encoding, "SJIS", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))
        -:   76:    return enc_sjis;
        -:   77:  return enc_other;
        -:   78:}
        -:   79:
        -:   80:# if GNULIB_WCHAR_SINGLE
        -:   81:/* When we know that the locale does not change, provide a speedup by
        -:   82:   caching the value of locale_enc.  */
        -:   83:static int cached_locale_enc = -1;
        -:   84:static inline enc_t
        -:   85:locale_enc_cached (void)
        -:   86:{
        -:   87:  if (cached_locale_enc < 0)
        -:   88:    cached_locale_enc = locale_enc ();
        -:   89:  return cached_locale_enc;
        -:   90:}
        -:   91:# else
        -:   92:/* By default, don't make assumptions, hence no caching.  */
        -:   93:#  define locale_enc_cached locale_enc
        -:   94:# endif
        -:   95:
        -:   96:/* This lock protects the internal state of mbtowc against multiple simultaneous
        -:   97:   calls of mbrtowc.  */
        -:   98:gl_lock_define_initialized(static, mbtowc_lock)
        -:   99:
        -:  100:verify (sizeof (mbstate_t) >= 4);
        -:  101:
        -:  102:static char internal_state[4];
        -:  103:
        -:  104:size_t
        -:  105:mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)
        -:  106:{
        -:  107:  char *pstate = (char *)ps;
        -:  108:
        -:  109:  if (s == NULL)
        -:  110:    {
        -:  111:      pwc = NULL;
        -:  112:      s = "";
        -:  113:      n = 1;
        -:  114:    }
        -:  115:
        -:  116:  if (n == 0)
        -:  117:    return (size_t)(-2);
        -:  118:
        -:  119:  /* Here n > 0.  */
        -:  120:
        -:  121:  if (pstate == NULL)
        -:  122:    pstate = internal_state;
        -:  123:
        -:  124:  {
        -:  125:    size_t nstate = pstate[0];
        -:  126:    char buf[4];
        -:  127:    const char *p;
        -:  128:    size_t m;
        -:  129:    enc_t enc;
        -:  130:    int res;
        -:  131:
        -:  132:    switch (nstate)
        -:  133:      {
        -:  134:      case 0:
        -:  135:        p = s;
        -:  136:        m = n;
        -:  137:        break;
        -:  138:      case 3:
        -:  139:        buf[2] = pstate[3];
        -:  140:        FALLTHROUGH;
        -:  141:      case 2:
        -:  142:        buf[1] = pstate[2];
        -:  143:        FALLTHROUGH;
        -:  144:      case 1:
        -:  145:        buf[0] = pstate[1];
        -:  146:        p = buf;
        -:  147:        m = nstate;
        -:  148:        buf[m++] = s[0];
        -:  149:        if (n >= 2 && m < 4)
        -:  150:          {
        -:  151:            buf[m++] = s[1];
        -:  152:            if (n >= 3 && m < 4)
        -:  153:              buf[m++] = s[2];
        -:  154:          }
        -:  155:        break;
        -:  156:      default:
        -:  157:        errno = EINVAL;
        -:  158:        return (size_t)(-1);
        -:  159:      }
        -:  160:
        -:  161:    /* Here m > 0.  */
        -:  162:
        -:  163:    enc = locale_enc_cached ();
        -:  164:
        -:  165:    if (enc == enc_utf8) /* UTF-8 */
        -:  166:      {
        -:  167:        /* Achieve multi-thread safety by not calling mbtowc() at all.  */
        -:  168:        /* Cf. unistr/u8-mbtouc.c.  */
        -:  169:        unsigned char c = (unsigned char) p[0];
        -:  170:
        -:  171:        if (c < 0x80)
        -:  172:          {
        -:  173:            if (pwc != NULL)
        -:  174:              *pwc = c;
        -:  175:            res = (c == 0 ? 0 : 1);
        -:  176:            goto success;
        -:  177:          }
        -:  178:        if (c >= 0xc2)
        -:  179:          {
        -:  180:            if (c < 0xe0)
        -:  181:              {
        -:  182:                if (m == 1)
        -:  183:                  goto incomplete;
        -:  184:                else /* m >= 2 */
        -:  185:                  {
        -:  186:                    unsigned char c2 = (unsigned char) p[1];
        -:  187:
        -:  188:                    if ((c2 ^ 0x80) < 0x40)
        -:  189:                      {
        -:  190:                        if (pwc != NULL)
        -:  191:                          *pwc = ((unsigned int) (c & 0x1f) << 6)
        -:  192:                                 | (unsigned int) (c2 ^ 0x80);
        -:  193:                        res = 2;
        -:  194:                        goto success;
        -:  195:                      }
        -:  196:                  }
        -:  197:              }
        -:  198:            else if (c < 0xf0)
        -:  199:              {
        -:  200:                if (m == 1)
        -:  201:                  goto incomplete;
        -:  202:                else
        -:  203:                  {
        -:  204:                    unsigned char c2 = (unsigned char) p[1];
        -:  205:
        -:  206:                    if ((c2 ^ 0x80) < 0x40
        -:  207:                        && (c >= 0xe1 || c2 >= 0xa0)
        -:  208:                        && (c != 0xed || c2 < 0xa0))
        -:  209:                      {
        -:  210:                        if (m == 2)
        -:  211:                          goto incomplete;
        -:  212:                        else /* m >= 3 */
        -:  213:                          {
        -:  214:                            unsigned char c3 = (unsigned char) p[2];
        -:  215:
        -:  216:                            if ((c3 ^ 0x80) < 0x40)
        -:  217:                              {
        -:  218:                                unsigned int wc
        -:  219:                                  = (((unsigned int) (c & 0x0f) << 12)
        -:  220:                                     | ((unsigned int) (c2 ^ 0x80) << 6)
        -:  221:                                     | (unsigned int) (c3 ^ 0x80));
        -:  222:                                if (wc <= WCHAR_MAX)
        -:  223:                                  {
        -:  224:                                    if (pwc != NULL)
        -:  225:                                      *pwc = wc;
        -:  226:                                    res = 3;
        -:  227:                                    goto success;
        -:  228:                                  }
        -:  229:                              }
        -:  230:                          }
        -:  231:                      }
        -:  232:                  }
        -:  233:              }
        -:  234:            else if (c <= 0xf4)
        -:  235:              {
        -:  236:                if (m == 1)
        -:  237:                  goto incomplete;
        -:  238:                else
        -:  239:                  {
        -:  240:                    unsigned char c2 = (unsigned char) p[1];
        -:  241:
        -:  242:                    if ((c2 ^ 0x80) < 0x40
        -:  243:                        && (c >= 0xf1 || c2 >= 0x90)
        -:  244:                        && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))
        -:  245:                      {
        -:  246:                        if (m == 2)
        -:  247:                          goto incomplete;
        -:  248:                        else
        -:  249:                          {
        -:  250:                            unsigned char c3 = (unsigned char) p[2];
        -:  251:
        -:  252:                            if ((c3 ^ 0x80) < 0x40)
        -:  253:                              {
        -:  254:                                if (m == 3)
        -:  255:                                  goto incomplete;
        -:  256:                                else /* m >= 4 */
        -:  257:                                  {
        -:  258:                                    unsigned char c4 = (unsigned char) p[3];
        -:  259:
        -:  260:                                    if ((c4 ^ 0x80) < 0x40)
        -:  261:                                      {
        -:  262:                                        unsigned int wc
        -:  263:                                          = (((unsigned int) (c & 0x07) << 18)
        -:  264:                                             | ((unsigned int) (c2 ^ 0x80)
        -:  265:                                                << 12)
        -:  266:                                             | ((unsigned int) (c3 ^ 0x80) << 6)
        -:  267:                                             | (unsigned int) (c4 ^ 0x80));
        -:  268:                                        if (wc <= WCHAR_MAX)
        -:  269:                                          {
        -:  270:                                            if (pwc != NULL)
        -:  271:                                              *pwc = wc;
        -:  272:                                            res = 4;
        -:  273:                                            goto success;
        -:  274:                                          }
        -:  275:                                      }
        -:  276:                                  }
        -:  277:                              }
        -:  278:                          }
        -:  279:                      }
        -:  280:                  }
        -:  281:              }
        -:  282:          }
        -:  283:        goto invalid;
        -:  284:      }
        -:  285:    else
        -:  286:      {
        -:  287:        /* The hidden internal state of mbtowc would make this function not
        -:  288:           multi-thread safe.  Achieve multi-thread safety through a lock.  */
        -:  289:        gl_lock_lock (mbtowc_lock);
        -:  290:
        -:  291:        /* Put the hidden internal state of mbtowc into its initial state.
        -:  292:           This is needed at least with glibc, uClibc, and MSVC CRT.
        -:  293:           See <https://sourceware.org/bugzilla/show_bug.cgi?id=9674>.  */
        -:  294:        mbtowc (NULL, NULL, 0);
        -:  295:
        -:  296:        res = mbtowc (pwc, p, m);
        -:  297:
        -:  298:        gl_lock_unlock (mbtowc_lock);
        -:  299:
        -:  300:        if (res >= 0)
        -:  301:          {
        -:  302:            if (pwc != NULL && ((*pwc == 0) != (res == 0)))
        -:  303:              abort ();
        -:  304:            goto success;
        -:  305:          }
        -:  306:
        -:  307:        /* mbtowc does not distinguish between invalid and incomplete multibyte
        -:  308:           sequences.  But mbrtowc needs to make this distinction.
        -:  309:           There are two possible approaches:
        -:  310:             - Use iconv() and its return value.
        -:  311:             - Use built-in knowledge about the possible encodings.
        -:  312:           Given the low quality of implementation of iconv() on the systems
        -:  313:           that lack mbrtowc(), we use the second approach.
        -:  314:           The possible encodings are:
        -:  315:             - 8-bit encodings,
        -:  316:             - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,
        -:  317:             - UTF-8 (already handled above).
        -:  318:           Use specialized code for each.  */
        -:  319:        if (m >= 4 || m >= MB_CUR_MAX)
        -:  320:          goto invalid;
        -:  321:        /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */
        -:  322:        switch (enc)
        -:  323:          {
        -:  324:          /* As a reference for this code, you can use the GNU libiconv
        -:  325:             implementation.  Look for uses of the RET_TOOFEW macro.  */
        -:  326:
        -:  327:          case enc_eucjp: /* EUC-JP */
        -:  328:            {
        -:  329:              if (m == 1)
        -:  330:                {
        -:  331:                  unsigned char c = (unsigned char) p[0];
        -:  332:
        -:  333:                  if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)
        -:  334:                    goto incomplete;
        -:  335:                }
        -:  336:              if (m == 2)
        -:  337:                {
        -:  338:                  unsigned char c = (unsigned char) p[0];
        -:  339:
        -:  340:                  if (c == 0x8f)
        -:  341:                    {
        -:  342:                      unsigned char c2 = (unsigned char) p[1];
        -:  343:
        -:  344:                      if (c2 >= 0xa1 && c2 < 0xff)
        -:  345:                        goto incomplete;
        -:  346:                    }
        -:  347:                }
        -:  348:              goto invalid;
        -:  349:            }
        -:  350:
        -:  351:          case enc_94: /* EUC-KR, GB2312, BIG5 */
        -:  352:            {
        -:  353:              if (m == 1)
        -:  354:                {
        -:  355:                  unsigned char c = (unsigned char) p[0];
        -:  356:
        -:  357:                  if (c >= 0xa1 && c < 0xff)
        -:  358:                    goto incomplete;
        -:  359:                }
        -:  360:              goto invalid;
        -:  361:            }
        -:  362:
        -:  363:          case enc_euctw: /* EUC-TW */
        -:  364:            {
        -:  365:              if (m == 1)
        -:  366:                {
        -:  367:                  unsigned char c = (unsigned char) p[0];
        -:  368:
        -:  369:                  if ((c >= 0xa1 && c < 0xff) || c == 0x8e)
        -:  370:                    goto incomplete;
        -:  371:                }
        -:  372:              else /* m == 2 || m == 3 */
        -:  373:                {
        -:  374:                  unsigned char c = (unsigned char) p[0];
        -:  375:
        -:  376:                  if (c == 0x8e)
        -:  377:                    goto incomplete;
        -:  378:                }
        -:  379:              goto invalid;
        -:  380:            }
        -:  381:
        -:  382:          case enc_gb18030: /* GB18030 */
        -:  383:            {
        -:  384:              if (m == 1)
        -:  385:                {
        -:  386:                  unsigned char c = (unsigned char) p[0];
        -:  387:
        -:  388:                  if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))
        -:  389:                    goto incomplete;
        -:  390:                }
        -:  391:              else /* m == 2 || m == 3 */
        -:  392:                {
        -:  393:                  unsigned char c = (unsigned char) p[0];
        -:  394:
        -:  395:                  if (c >= 0x90 && c <= 0xe3)
        -:  396:                    {
        -:  397:                      unsigned char c2 = (unsigned char) p[1];
        -:  398:
        -:  399:                      if (c2 >= 0x30 && c2 <= 0x39)
        -:  400:                        {
        -:  401:                          if (m == 2)
        -:  402:                            goto incomplete;
        -:  403:                          else /* m == 3 */
        -:  404:                            {
        -:  405:                              unsigned char c3 = (unsigned char) p[2];
        -:  406:
        -:  407:                              if (c3 >= 0x81 && c3 <= 0xfe)
        -:  408:                                goto incomplete;
        -:  409:                            }
        -:  410:                        }
        -:  411:                    }
        -:  412:                }
        -:  413:              goto invalid;
        -:  414:            }
        -:  415:
        -:  416:          case enc_sjis: /* SJIS */
        -:  417:            {
        -:  418:              if (m == 1)
        -:  419:                {
        -:  420:                  unsigned char c = (unsigned char) p[0];
        -:  421:
        -:  422:                  if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)
        -:  423:                      || (c >= 0xf0 && c <= 0xf9))
        -:  424:                    goto incomplete;
        -:  425:                }
        -:  426:              goto invalid;
        -:  427:            }
        -:  428:
        -:  429:          default:
        -:  430:            /* An unknown multibyte encoding.  */
        -:  431:            goto incomplete;
        -:  432:          }
        -:  433:      }
        -:  434:
        -:  435:   success:
        -:  436:    /* res >= 0 is the corrected return value of mbtowc (pwc, p, m).  */
        -:  437:    if (nstate >= (res > 0 ? res : 1))
        -:  438:      abort ();
        -:  439:    res -= nstate;
        -:  440:    pstate[0] = 0;
        -:  441:    return res;
        -:  442:
        -:  443:   incomplete:
        -:  444:    {
        -:  445:      size_t k = nstate;
        -:  446:      /* Here 0 <= k < m < 4.  */
        -:  447:      pstate[++k] = s[0];
        -:  448:      if (k < m)
        -:  449:        {
        -:  450:          pstate[++k] = s[1];
        -:  451:          if (k < m)
        -:  452:            pstate[++k] = s[2];
        -:  453:        }
        -:  454:      if (k != m)
        -:  455:        abort ();
        -:  456:    }
        -:  457:    pstate[0] = m;
        -:  458:    return (size_t)(-2);
        -:  459:
        -:  460:   invalid:
        -:  461:    errno = EILSEQ;
        -:  462:    /* The conversion state is undefined, says POSIX.  */
        -:  463:    return (size_t)(-1);
        -:  464:  }
        -:  465:}
        -:  466:
        -:  467:#else
        -:  468:/* Override the system's mbrtowc() function.  */
        -:  469:
        -:  470:# undef mbrtowc
        -:  471:
        -:  472:size_t
        -:  473:rpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)
        -:  474:{
        -:  475:  size_t ret;
        -:  476:  wchar_t wc;
        -:  477:
        -:  478:# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG
        -:  479:  if (s == NULL)
        -:  480:    {
        -:  481:      pwc = NULL;
        -:  482:      s = "";
        -:  483:      n = 1;
        -:  484:    }
        -:  485:# endif
        -:  486:
        -:  487:# if MBRTOWC_EMPTY_INPUT_BUG
        -:  488:  if (n == 0)
        -:  489:    return (size_t) -2;
        -:  490:# endif
        -:  491:
      257:  492:  if (! pwc)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  493:    pwc = &wc;
        -:  494:
        -:  495:# if MBRTOWC_RETVAL_BUG
        -:  496:  {
        -:  497:    static mbstate_t internal_state;
        -:  498:
        -:  499:    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the
        -:  500:       hidden internal state, but we can call it on our variable.  */
        -:  501:    if (ps == NULL)
        -:  502:      ps = &internal_state;
        -:  503:
        -:  504:    if (!mbsinit (ps))
        -:  505:      {
        -:  506:        /* Parse the rest of the multibyte character byte for byte.  */
        -:  507:        size_t count = 0;
        -:  508:        for (; n > 0; s++, n--)
        -:  509:          {
        -:  510:            ret = mbrtowc (&wc, s, 1, ps);
        -:  511:
        -:  512:            if (ret == (size_t)(-1))
        -:  513:              return (size_t)(-1);
        -:  514:            count++;
        -:  515:            if (ret != (size_t)(-2))
        -:  516:              {
        -:  517:                /* The multibyte character has been completed.  */
        -:  518:                *pwc = wc;
        -:  519:                return (wc == 0 ? 0 : count);
        -:  520:              }
        -:  521:          }
        -:  522:        return (size_t)(-2);
        -:  523:      }
        -:  524:  }
        -:  525:# endif
        -:  526:
      257:  527:  ret = mbrtowc (pwc, s, n, ps);
call    0 returned 100%
        -:  528:
        -:  529:# if MBRTOWC_NUL_RETVAL_BUG
        -:  530:  if (ret < (size_t) -2 && !*pwc)
        -:  531:    return 0;
        -:  532:# endif
        -:  533:
        -:  534:# if MBRTOWC_IN_C_LOCALE_MAYBE_EILSEQ
      257:  535:  if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
        -:  536:    {
    #####:  537:      unsigned char uc = *s;
    #####:  538:      *pwc = uc;
    #####:  539:      return 1;
        -:  540:    }
        -:  541:# endif
        -:  542:
      257:  543:  return ret;
        -:  544:}
        -:  545:
        -:  546:#endif
